* functions
** charact prog
   python es:
   -dinámico: no se comprueban los tipos de datos. De hecho se checkean los tipos a medida que se van
   generando
   -interpretado: se omite el proceso de compilación, ejecución y depuración
** encabezado
*** begin prog
   """
   %@author: ntrivisonno
   
   script for bifurcation diagram or logistic map
   """
*** end prog
   print('#--------------------------------------------')
   print('\n FIN, OK!')

   plt.show()
** assert
   excepciones, se usa para evitar que el prog se interrumpa frente 
   a un error
*** exception ad-hoc
**** ej
     a = 4; b = 0

     try:
         c = a/b
     except ZeroDivisionError:
	 print("No se ha podido realizar la división")

     # ZeroDivisionError: division by zero
     print ("paso assert")
*** clase Exception
    ahora en lugar de enumerar a cada excepcion, se llama a Exception,
    ya que las execpsiones heredan de Exception
**** ej
     a = 4; b = 0

     try:
         c = a/b
	 c = a+"2"
     except Exception as ex:
         print("Ha habido una excepción: ",type(ex))

     # ZeroDivisionError: division by zero
     print ("paso assert")

*** estructura assert,else y finally
    se incorpora la sentencia finally, dicho bloque se ejecuta siempre,
    haya o no ocurrido una excepción. Esto se hace x ejemplo si ocurre
    una excepción y sale del bucle try, pero puede que queden algunas 
    cosas sin hacer, entonces con finally, se puede "resetear todo"
**** ej
     try:
         # Forzamos excepción
         x = 2/0
     except:
         # Se entra ya que ha habido una excepción
         print("Entra en except, ha ocurrido una excepción")
     finally:
     # También entra porque finally es ejecutado siempre
         print("Entra en finally, se ejecuta el bloque finally")

     #Entra en except, ha ocurrido una excepción
     #Entra en finally, se ejecuta el bloque finally
** arrays/vectores
*** row vs column vector
    import numpy as np
    #(5,2)
    row = np.array([[0, 1], [0, 1], [0, 1], [0, 1], [0, 1]])
    
    #(2,5)
    col = np.array([[8, 8, 8, 8, 8],[8, 8, 8, 8, 8]])

*** crear un vector/array
    import numpy as np
    # data matrix 2x4
    data = np.array([[1, 2, 3, 4],[5, 6, 7, 8]])

    print('data')
    print(data)
    print('np.shape(data)')
    print(np.shape(data))
    
    print('data[0,:]')
    print(data[0,:])

    print('data[:,1]')
    print(data[1,:])
*** arange vs linspace
    hay dos formas de crear un vector a partir de un "dt" o "N" steps
***** arange
      import numpy as np
      # arange(x0,xf,dx)
      a = np.arange(0,5,2) # cout=[0 2 4]
***** linspace
      import numpy as np
      # linspace(x0,xf,N)
      a = np.linspace(0,5,2) # cout=[0 5]
*** acceder a filas/columnas vec
    # pruebas para trabajar y acceder a vectores
    import numpy as np

    n = 3
    m = 4
    
    datafil = np.zeros((n,m))
    
    datacol = datafil
    #data = np.array([[1, 2, 3, 4],[5, 6, 7, 8],[9, 10, 11, 12]])
    datafil[1, :] =  [1, 2, 3, 4]
    pp = np.ones((n,n))
    print('shape(pp)')
    print(np.shape(pp))
    print('shape(datafil)')
    print(np.shape(datafil))
    print('datafil')
    print(datafil)
    print('pp')
    print(pp)
    print('datacol')
    print(datacol)

    datacol[:, m-1] =  pp[:,2]

    print('datacol')
    print(datacol)
    print('np.shape(datacol)')
    print(np.shape(datacol))
*** generar un vector a partir de un archivo txt
**** ex
     # Nombre del archivo de entrada
     archivo_entrada = "numeros.txt"

     # Leer el archivo y crear una lista de números
     with open(archivo_entrada, "r") as archivo:
         lineas = archivo.readlines()

     # Eliminar espacios en blanco y saltos de línea, y convertir a números de punto flotante
     numeros = [float(linea.strip()) for linea in lineas]

     # Convertir la lista de números en una cadena con comas
     cadena_numeros = ",".join(map(str, numeros))

     printa(cadena_numeros)  # Imprime la cadena de números separados por comas

*** trabajar arreglos como listas
    import numpy as np
    tt = [] # crea lista
    print('type(tt)')
    print(type(tt))
    tta = np.asarray(tt) # transformamos lista a array
    print('type(tta)')
    print(type(tta))
*** warning/error of array with different length
    see warnings section at the end of the file
*** matrices no simetricas
    para crear una matriz de zeros de 4 filas y 5 columnas
    filas = 4
    columnas = 5

    matriz = [[0] * columnas for _ in range(filas)]
** append
   metodo de una clase que agrega algo (num,lista, etc) a algo ya existente
*** ej
   agrega lo que le pasamos al vector
   a=[0,1,2] #a.append(3)print a
   print a
   #>> [0, 1, 2]
   a.append(3)
   #>> [0, 1, 2, 3]
   se puede apendizar vectores, etc
   >>> b=[9, 9]
   >>> b
   [9, 9]
   >>> a.append(b)
   >>> a
   [0, 1, 2, 3, 55, [9, 9]]
** cambios de ',' por '.' para los flotantes
*** ex
    # script cambia , por .
    import numpy as np
    import matplotlib.pyplot as plt

    with open ("./Vel_mag.csv") as f_input:
        text = [l.replace(",", ".") for l in f_input]

    data = np.loadtxt(text, delimiter=';')

    np.savetxt('Vel_mag.csv',data,delimiter=";")

** comments
   para comentar una funci'on se usa la triple comilla ('''), de esta 
   forma si se hace bien al principio se usa para describir el atributo o el 
   método. Esto se denomina docstring y se llama al atributo __doc__
*** ej:
    # Functions
    def euler(xk,dt,A,B,uk):
        '''
        euler: integrator function for ODE with euler scheme
        xk: states vector
        dt: incremental time
        A: system matrix,
        B: system matrix,
        uk: control state
        x_next: state solution of the ODE
        '''    
        x_next = xk + dt*(np.dot(A,xk)+np.dot(B,uk))
        return x_next

    print("euler.__doc__")
    print(euler.__doc__) #show docstring of the function,method or attribute
** data
**** objeto
     f = open(filename, mode, encoding=None)
     ‘r’, este es el modo predeterminado, que abre un archivo para leer
     ‘w’, este modo abre un archivo para escritura, si el archivo no existe, crea un nuevo archivo.
     ‘a’, abre un archivo en modo anexar, agrega datos al final del archivo. Si el archivo no existe, crea un nuevo archivo.
     ‘b’, abre un archivo en modo binario.
     ‘r +’, abre un archivo (no crear) para leer y escribir.
     ‘w +’, abre o crea un archivo para escribir y leer, descarta el contenido existente.
     ‘a +’, abre o crea un archivo para leer y escribir, y agrega datos al final del archivo.
     encoding="utf-8". Because UTF-8 is the modern de-facto standard. encodeing='b', binary
*** leer data
**** numpy
    # example by lucas
    # nos creamos un vector de casos para acceder a disintos simulaciones
    CASO = 0
    data = np.loadtxt('Resu_RBD/' + ['Forces_proc_C_C01.txt', 'Forces_proc_C_C02.txt', 'Forces_proc_C_C03.txt'][CASO], delimiter=',', skiprows=1)
    # Encabezado del txt:xo
    # Time, alpha, beta, delta2, V_inf (= V_t), u(v_body_X), v(v_body_Y), w(v_body_Z), p, q, r, gx, gy, gz, FX_body, FY_body, FZ_body
    M = data[:,0]
    alpha = data[:, 1]
    beta = data[:, 2]
    delta2 = data[:, 3]  # alpha2
    vt = data[:, 4]
    u = data[:, 5]  # vel_body_X
**** objeto
***** example
      f = open('./test.txt', 'r')
      content = f.read()
      f.close()
      print(content)
*** escribir data
**** numpy
      np.savetxt('nombre_archivo', objeto_guardar, formato_salida, encabezado)
      formato_salida: %.2f -> flotantes con dos decimales
***** example
      import numpy as np
      arr = np.array([[1.20, 2.20, 3.00], [4.14, 5.65, 6.42]])
      np.savetxt('my_arr.txt', arr, fmt='%.2f', header = 'Col1 Col2 Col3')
**** archivo    
***** example
      #Escribimos un poco
      f = open('test.txt', 'w')
      for i in range(5):
         f.write(f"Linea numero {i}\n")
    
      f.close()

**** agragar linea al txt
     f = open('test.txt', 'a')
     f.write(f"Agrego una linea mas\n")
     f.close()
** dhf5
*** read 
    import h5py

    h5f = h5py.File('Data_vacio.hdf5','r')
    x = h5f['/Inertial_coord'][:] # me importa un vector x de size-> print(np.shape(x)) (1001,3)
    t = h5f['/Time'][:]
    h5f.close()
*** ver todos los campos
    import h5py
    h5f=h5py.File(resul+'Data.hdf5','r')
    campos = list(h5f.keys())
** dict
   diccionario
*** definir
    dic = {'CustID': [1, 2, 3],
    'Name': ['Peter', 'Aldo', 'Pedro']}
    
    # grupos
    dic.keys()
*** acceder a valores
    nombres = dic['Names']
*** incorporar un valor nuevo
    existen varias formas:
**** usando corchetes
     # nombre del diccionario[clave]=valor/es 
     dic['Edades'] = [4, 5, 6]
**** metodo update
     dic.update({'key' : valores})
     dic.update({'Edades' : [4, 5, 6]})
*** incorporar un valor a clave ya existente
    ver
*** métodos populares
**** clear
     method that removes all the items for the dict

     mydict = {'name': 'Nico', 'age': 35}
     mydict.clear()
     print(mydict)
**** copy
     method that returns a shallow copy of the dict

     mydict = {'name': 'Nico', 'age': 35}
     mynewdict = mydic.copy()
     newdict['age'] = 30
     print(mydic)
     print(mynewdic)
**** get
**** items
     method returns a list of key-values pairs in dict
     basically retuns everything of the dict (key+values)
     
     mydict = {'name': 'Nico', 'age': 35}
     items = mydic.items()
     print(items)
**** keys
     method returns a list of the keys in the dict
     
     mydict = {'name': 'Nico', 'age': 35}
     key = mydict.keys()
     print(keys)
**** popitem
**** values
     method retuns a list of values in the dict
     just returns values, not key of the dict

     mydict = {'name': 'Nico', 'age': 35}
     values = mydict.values()
     print(values)
**** pop
     method taht removes and return value of the specific key.
     if the key doesn't exist, it raise a keyError. To avoid it,
     you cna pass a default value to avoid the error

     mydict = {'name': 'Nico', 'age': 35}
     age = mydict.pop('age')
     print(age) #value que eliminió
     print(mydict) #resu del dict
**** update
     method updates the dict with the specified key-values pairs
     
     mydict = {'name': 'Nico', 'age': 35, 'country': 'Arg'}
     mydict.update('age': 25)
     print(mydict)
**** setdefault
     method returns the value of a specified key
     no termino de entender su aplicación

     mydict = {'name': 'Nico', 'age': 35}
     country = mydict
     setdefault('country', 'Arg')
     print(country)
     print(mydict)
** enumerate
*** ex1 - base 1
   # use python3
   # en realidad se puede colocar cualquier indice
   names = ['Bob', 'Alice', 'Guido']
   for index, value in enumerate(names, 1):
        print(f'{index}: {value}')
*** ex1 - base 0
   # use python3
   names = ['Bob', 'Alice', 'Guido']
   for index, value in enumerate(names):
        print(f'{index}: {value}')
** eps
   for using eps

   eps = np.finfo(float).eps
** is vs ==
   is compara si son iguales a donde apunta un puntero, == evalua si el valor del puntero es el mismo

   "is" expressions evaluate to True if two 
   variables point to the same object

   "==" evaluates to True if the objects 
   referred to by the variables are equal
*** ej
   a = [1 2 3]
   a = b
   a is b
   ## True
   a == b
   ## True
   c = list(a)
   a == c
   ## True
   a is c
   ## false
   
** inspect
   import inspect
   La librería inspect en Python proporciona una serie de herramientas para examinar 
   objetos vivos en tiempo de ejecución. Esta biblioteca es útil para obtener información
   sobre módulos, clases, funciones, métodos, etc. Permite inspeccionar y analizar el 
   código fuente, estructura y otros detalles de los objetos durante la ejecución del 
   programa.
*** ejemplos
**** inspect.getmembers(object[, predicate]): 
    Retorna todos los miembros de un objeto, incluyendo atributos, métodos, etc. Puede 
    aceptar un predicado opcional para filtrar los miembros.
**** inspect.ismodule(object), inspect.isclass(object), inspect.isfunction(object)
    Estas funciones verifican si un objeto dado es un módulo, una clase, una función, etc.
**** inspect.getsource(object)
    Devuelve el código fuente de un objeto si está disponible.
**** inspect.signature(func)
    Devuelve un objeto que representa la firma de la función pasada como argumento, 
    permitiendo el acceso a los parámetros y sus propiedades.
**** inspect.getdoc(object)
    Retorna la documentación (docstring) de un objeto si está disponible.
**** inspect.getfile(object)
    Retorna la ruta al archivo fuente en el que se definió un objeto si está disponible
** =
   ojo con el igual, que hace que apunte al mismo lugar de dirección
   el signo igual (para un arreglo) es un puntero a la dir de la 1er variable,
   puede dar error, si se desea sobre-escribir alguna variable.
   Solución -> usar el método arreglo.copy()
*** ej
    import numpy as np
    a = np.array(([1, 2, 3]))
    aorig = a #ojo no sobre-escribe
    a *= 2
    print("aorig: {}".format(aorig))
    print("a: {}".format(a))
    #error a == aorig
    # solo
    import numpy as np
    print("aorig: {}".format(aorig))
    aorig = a.copy() # sol
    print("aorig: {}".format(aorig))
    print("aorig: {}".format(aorig))
    print("a: {}".format(a))
** lambda function
   es una función para crear una función inline o para hacer una función de forma recursiva
*** ej:
    # testing lambda function
    suma = lambda a,b: a+b
    
    resu = suma(2,4)

    print("el resultado es suma(2,4)= {}".format(resu))
    print("el resultado es suma(2,4)= {}".format(lambda a,b: a+b(2,4)))
    print(((lambda a,b: a+b))(2,4))
    tmb la funcion puede devolver mas de un valor
*** ej
    # testing lambda function
    suma = lambda a,b: (a,b)

    print(suma(2,4))
*** conocer la ley de la función
    para conocer la ley de la función, lo mismo que para otras funciones, se debe usar la 
    libería inspect.
    ya que de lo contrario, al poner print(lambdaFun) mostrará la dirección de memoria
    donde se encuentra almacenada.
**** ej
     import inspect
     import numpy as np
     # función Blausios para calcular espesor de capa límite
     delta = lambda Re, r, L: 5 * L / (np.sqrt(Re)) * np.sqrt( r / L)
     print('La función tiene la ley:')
     print(inspect.getsource(delta))
** list
   es una estructura definida [], que tiene una gran cantidad de métodos asociados
   # lista != tupla
   a = [(1,2,1+j,'5')]
   for i in a:
       print(i)
*** métodos listas
**** append(x)
     le incorpora un elemento a lo último
     a = [(1,2,1+j,'5')]
     a.append(5)
     print(a)
**** extend
     sería un append pero se le incorpora un iterador (vector, lista, etc)
     a = [(1,2,1+j,'5')]
     a.extend(range(5))
     print(a)
**** insert(i,x)
     # se inserta un valor en la posicion i
     a = [1,2,1+2,'5']
     a.insert(1,1.5) # insertamos un valor intermedio
     print(a)
**** remove(x)
     #Remove the first item from the list whose value is equal to x. It raises a ValueError if there is no such item
     a = [1,2,1+2,'5']
     b = list(a)
     b.remove(2)
     print(a)
** list comprehension
   List comprehensions in Python are a concise way to create new lists
   based on existing lists or other iterable objects. They allow you to
   perform operations on each element of the original list and generate
   a new list in a single line of code. Here's the basic syntax of a 
   list comprehension:

   new_list = [expression for item in iterable if condition]

   el principal uso es para identificar de forma visual que se está 
   creando una lista explicitando lo que se hace con la misma. Los 
   for meten mucho ruido y es más dificil de leer
*** ej
    numbers = [1, 2, 3, 4, 5]
    squares = [x**2 for x in numbers]
    print(squares)  # Output: [1, 4, 9, 16, 25]

    # ej2 num pares
    numbers = [1, 2, 3, 4, 5]
    evens = [x for x in numbers if x % 2 == 0]
    print(evens)  # Output: [2, 4]
    # ej3 sobre un vector calc la dif del cuadrado del consecutivo
    vec = np.arange(4)
    vec2 = [x**2 for x in vec]
    dif = [vec2[x+1] - vec2[x] for x in range(len(vec)-1)]
    # ej4
    fruits = ['apple', 'banana', 'cherry']
    colors = ['red', 'yellow', 'red']
    pairs = [(fruit, color) for fruit in fruits for color in colors]
    print(pairs)
    # Output:
    [('apple', 'red'), ('apple', 'yellow'), ('apple', 'red'), ('banana', 'red'),....
    ....('banana', 'yellow'), ('banana', 'red'), ('cherry', 'red'),..
    ....('cherry', 'yellow'), ('cherry', 'red')]

** file
   file handling
   pythong has several methods (functions) for handling files
*** create
    to create a file, should use the 'open' method with:
    - 'x' -> create, runs ERRORS if doesn't exist
    - 'w' -> write, open a files for writing, creates the files is 
    doesn't exist
    - 'a' -> append, apendding, creates a file if doesn't exist   
*** open
    open(name_file, method)
    there are several methods for opening files: x, w, r, a, t, b
    - 'r' -> read, DEFAULT VALUE, opens a file for reading, ERROR if 
    doesn't exits
    - 'x' -> create, runs ERRORS if doesn't exist
    - 'w' -> write, open a files for writing, creates the files is 
    doesn't exist
    - 'a' -> append, apendding, creates a file if doesn't exist
    additionally, can specify the type:
    - 't' -> text, DEFAULT
    - 'b' -> binary (eg, pictures)
*** write
    use the open() method
**** new file
    open()
    - 'x' -> create, runs ERRORS if doesn't exist
    - 'w' -> write, open a files for writing, creates the files is 
    doesn't exist
    - 'a' -> append, apendding, creates a file if doesn't exist
**** existing file
     open()
    - 'w' -> write, open a files for writing, creates the files is 
    doesn't exist
    - 'a' -> append, apendding, creates a file if doesn't exist   
*** reading
    use open() method, with 'r', DEFAULT value, ERROR if doesn't
    exist
**** example
    f = open('myfile.txt', 'r')
    data = f.read()
    print(data)
    f.close()
*** example
**** open, write
    f = open('myfile.txt','x') # x -> create
    data = 'Hello world'
    f.write(data)
    f.close()
**** writing vector
     data = [1.6, 3.4, 6.2]
     f = open('mytext.txt', 'x')
     for _i in data:
          record = str(value)
	  f.write(record)
	  f.write('\n') #new line
     f.close()
**** replace
     f = open('mytext.txt', 'r')
     for _i in f:
          record = record.replace('\n', ' ')
	  print(record)
     f.close()
** for
*** directo
   el bucle for establece una variable iteradora en cada valor de la lista.
   # lista != tupla
   a = [(1,2,1+j,'5')]
   for i in a:
       print(i)
      
   si por ejemplo los valores de lista son valores secuenciales se puede usar la funcion range()
*** for i in range()
    bucle for para cuando los valores de lista arecorrer son valores secuenciales
    la funcion range() tiene los sig argumentos de entrada: range(inicio,fin,paso)
    por defecto range(), comienza en 0 y tiene incremento 1
**** ej
     for i in range(-1,5,2):
        print(i,end=", ")
** functions
   las funciones en python se usan para varias cosas:
   - como argumento de otras funciones
   - retornan valores de otras funciones
   - se le asignan variables y las almacena en dato de estructura
*** ej
    def myfun(a+b):
    return a+b

    >>> funcs = [myfun]
    >>> funcs[0]
    <function myfunc at 0x107012230>
    >>> funcs[0](2,3)
    5
** maps
   Benefits of the Python map function:
   - Transforms data effortlessly, saving time.
   - Boosts code readability – cleaner, concise scripts.
   - Unleashes parallel processing for speedier results.
*** ej
    # vieja escuela approach 
    number = input('Enter number with spaces: ').split()
    digits = list()

    for num in numbers:
        num = int(num)
	digits.append(num)

    # nueva escuela approach
    numbers = list(map(int, input('Enter number with spaces: ').split()))

** odeint - scipy
   integrador de ODEs
   https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html
*** ej
    import scipy.integrate as integrate
    import matplotlib.pyplot as plt
    import numpy as np
    
    #ODE: u'' = a*u + b*u' + c --> if a < 0, oscilation
    a = -1; b = -0.5; c = 0.1;

    def deriv_z(z, phi):
    u, udot = z
    return [udot, (a*u + b*udot + c)]
    
    phi = np.linspace(0, 20, 2000)
    zinit = [2, 0]
    z = integrate.odeint(deriv_z, zinit, phi)
    u, udot = z.T
    plt.plot(phi, u, label='u')
    plt.plot(phi, udot, label="u'")
    plt.legend(loc=1)
    plt.grid(True)
    plt.show()
** os
   liberia para interactuar con el sistema operativo (operating system)
*** métodos más populares
**** métodos populares
os.path.join(path, *paths): Combina uno o más componentes de ruta en una sola ruta.
os.path.abspath(path): Devuelve la ruta absoluta del archivo o directorio dado.
os.path.dirname(path): Devuelve el directorio principal de una ruta.
os.path.basename(path): Devuelve el componente final de una ruta.
os.path.exists(path): Comprueba si la ruta especificada existe.
os.path.isfile(path): Comprueba si la ruta especificada apunta a un archivo.
os.path.isdir(path): Comprueba si la ruta especificada apunta a un directorio.
os.listdir(path='.'): Devuelve una lista con los nombres de los elementos en el directorio dado.
os.mkdir(path): Crea un nuevo directorio.
os.makedirs(name): Crea directorios recursivamente.
os.remove(path): Elimina un archivo.
os.rmdir(path): Elimina un directorio vacío.
os.removedirs(path): Elimina directorios recursivamente.
os.rename(src, dst): Renombra un archivo o directorio.
os.getcwd(): Devuelve el directorio de trabajo actual.     
*** obtener valores de las carpetas del directorio actual, 
    ej: levantar las carpetas de tiempos de una corrida de OF
**** ej:
# script que levanta todo los nombres (carpeta y archivos) de un directorio y filtra los paso del tiempo de una corrida de OF
import os
import csv


# Ruta del directorio
directorio = "./"  # Reemplaza esto con la ruta correcta

# Lista para almacenar los pasos de tiempo
pasos_de_tiempo = []

# Recorre el directorio
for entrada in os.listdir(directorio):
    ruta_completa = os.path.join(directorio, entrada)

    # Verifica si es un directorio y tiene un formato num�rico (podr�a ser un paso de tiempo)
    if os.path.isdir(ruta_completa) and entrada.replace(".", "", 1).isdigit():
        pasos_de_tiempo.append(float(entrada))  # Convierte a tipo float

# Ordena la lista de pasos de tiempo
pasos_de_tiempo.sort()

# Imprime la lista resultante
print(pasos_de_tiempo)
print(f'Se guardaron los pasos de tiempo en la variable: "pasos_de_tiempo"')

# write csv file
nombreArchivo = 'tiempoOF_csv'
ruta_csv = os.path.join(os.getcwd(), nombreArchivo)
with open(ruta_csv, 'w', newline='') as archivo_csv:
    escritor_csv = csv.writer(archivo_csv)
    escritor_csv.writerow(['Pasos de Tiempo'])  # Escribir encabezado
    for paso_tiempo in pasos_de_tiempo:
        escritor_csv.writerow([paso_tiempo])
*** para ver el dicrectorio actual y cambiarlo
    obtener el directorio actual e ir una folder p atrás relativa
**** ej
import os
import sys

# Obtener el directorio actual
current_directory = os.getcwd()

# Ir una carpeta hacia atrás
parent_directory = os.path.dirname(current_directory)

# Agregar la ruta de la carpeta anterior al sys.path
sys.path.append(parent_directory)

# Verificar si la ruta se ha agregado correctamente
print("Ruta agregada al sys.path:", parent_directory)

**** ir folder para atrás de forma recursiva
import os
import sys

def add_parent_directories(num_levels):
    # Obtenemos el directorio actual
    current_directory = os.getcwd()

    # Retrocedemos num_levels veces
    for _ in range(num_levels):
        current_directory = os.path.dirname(current_directory)

    # Agregamos la ruta de la carpeta anterior al sys.path
    sys.path.append(current_directory)

    # Mostramos la ruta agregada al sys.path
    print(f"Ruta agregada al sys.path: {current_directory}")

# Número de niveles que queremos retroceder
num_levels_back = 2  # Cambia a la cantidad deseada de niveles

# Llamamos a la función para agregar los directorios
add_parent_directories(num_levels_back)
** pdf
*** unir dos pdf
**** ej
import PyPDF2

def unir_pdfs(archivo1, archivo2, archivo_salida):
    # Abrir los archivos PDF en modo de lectura binaria
    with open(archivo1, 'rb') as file1, open(archivo2, 'rb') as file2:
        # Crear objetos de lectura para ambos archivos PDF
        pdf_reader1 = PyPDF2.PdfReader(file1)
        pdf_reader2 = PyPDF2.PdfReader(file2)

        # Crear un objeto de escritura para el archivo de salida
        pdf_writer = PyPDF2.PdfWriter()

        # Agregar todas las páginas del primer archivo
        for pagina in range(len(pdf_reader1.pages)):  # Utiliza len(reader.pages)
            pdf_writer.add_page(pdf_reader1.pages[pagina])

        # Agregar todas las páginas del segundo archivo
        for pagina in range(len(pdf_reader2.pages)):  # Utiliza len(reader.pages)
            pdf_writer.add_page(pdf_reader2.pages[pagina])

        # Guardar el resultado en un nuevo archivo PDF
        with open(archivo_salida, 'wb') as file_salida:
            pdf_writer.write(file_salida)

# Ejemplo de uso
archivo1 = '/home/zeeburg/Downloads/portfolio_CAD.pdf'
archivo2 = '/home/zeeburg/Downloads/cv_Trivisonno.pdf'
archivo_salida = '/home/zeeburg/Downloads/resultado.pdf'

unir_pdfs(archivo1, archivo2, archivo_salida)

*** pdf2word
   library to convert pdf2word
**** ej
    #pip3 install pdf2docx
    from pdf2docx import Converter
    pdf_file = '2008-Ueno_Drag_decomposition_Analysis.pdf'
    word_file = '2008-Ueno_Drag_decomposition_Analysis.docx'
    cv = Converter(pdf_file)
    cv.convert(word_file)
cv.close()
** plot
   si hay varios plots y queremos que se muestren todos a lo último, 
   podemos hacer un plt.show() a lo último, o en cada plt.show() poner:
   plt.plot(block=False)
*** plotea dos plot en una sola graf
**** ej
     import numpy as np
     import matplotlib.pyplot as plt

     M_eg = [0.1,  0.6,  0.8,  0.9,  0.95, 1.,   1.05, 1.1,  1.2,  1.35, 1.5,  1.75, 2.  ]
     Ca_eg= [0.144, 0.144, 0.146, 0.167, 0.221, 0.327, 0.383, 0.381, 0.37,  0.353, 0.338, 0.314,
     0.294]
     M_ba = [0.01,  0.4,   0.6,   0.7,   0.8,   0.9,   0.95,  0.975, 1.,    1.025, 1.05,  1.1,
     1.2,   1.5,   2.,    2.5,   3.   ]
     Ca_ba = [0.144, 0.144, 0.144, 0.144, 0.146, 0.16,  0.202, 0.24,  0.284, 0.313, 0.332, 0.337,
     0.34,  0.321, 0.276, 0.24,  0.214]

     plt.plot(M_eg,Ca_eg,'o-r',label='Egip')
     plt.plot(M_ba,Ca_ba,'*-b',label='Baran')
     plt.xlabel('Mach')
     plt.ylabel('Ca')
     plt.title('Ca')
     plt.legend()
     plt.show()
*** subplot
**** automatizado
     # script para plotear vectores automatizado
     import numpy as np
     import matplotlib.pyplot as plt
     # carga de datos
     M_eg = []
     M_eg = np.asarray([0.1,  0.6,  0.8,  0.9,  0.95, 1.,   1.05, 1.1,  1.2,  1.35, 1.5,  1.75, 2.  ])
     Ca_eg = np.asarray([0.144, 0.144, 0.146, 0.167, 0.221, 0.327, 0.383, 0.381, 0.37,  0.353, 0.338, 0.314, 0.294])
     
     M_eg2 = M_eg*2.
     Ca_eg2 = Ca_eg*2.
     
     M_eg3 = M_eg*3
     Ca_eg3 = Ca_eg*3
     
     #M_ba = np.asarray([0.01,  0.4,   0.6,   0.7,   0.8,   0.9,   0.95,  0.975, 1.,    1.025, 1.05,  1.1, 1.2,   1.5,   2.,    2.5,   3.   ])
     #Ca_ba = np.asarray([0.144, 0.144, 0.144, 0.144, 0.146, 0.16,  0.202, 0.24,  0.284, 0.313, 0.332, 0.337, 0.34,  0.321, 0.276, 0.24,  0.214])
     # aca empieza la automatizacion     
     M = []
     M = np.asarray([M_eg, M_eg, M_eg])
     M = M.T
     C = []
     C = np.asarray([Ca_eg, Ca_eg2, Ca_eg3])
     C = C.T
     leg = ['Mach', 'Mach 2', 'Mach 3']
     
     [i,j] = np.shape(M)
     
     fig_size = (12,4)
     f, ax = plt.subplots(1,3, figsize=fig_size)
     f.canvas.set_window_title('Coordenadas en marco inercial')
     f.suptitle('Coordenadas en marco inercial')
     for k in range(j):
         ax[k].plot(M[:,k], C[:,k], label=leg[k])
         ax[k].set_title(leg[k])
         ax[k].legend()
         ax[k].grid()
         ax[k].set_xlabel('time [s]')
         ax[k].set_ylabel('Mz [Nm]')
     
     plt.show()
   
**** a pata
     import numpy as np
     import matplotlib.pyplot as plt
     
     M_eg = [0.1,  0.6,  0.8,  0.9,  0.95, 1.,   1.05, 1.1,  1.2,  1.35, 1.5,  1.75, 2.  ]
     Ca_eg= [0.144, 0.144, 0.146, 0.167, 0.221, 0.327, 0.383, 0.381, 0.37,  0.353, 0.338, 0.314,
     0.294]
     M_ba = [0.01,  0.4,   0.6,   0.7,   0.8,   0.9,   0.95,  0.975, 1.,    1.025, 1.05,  1.1,
     1.2,   1.5,   2.,    2.5,   3.   ]
     Ca_ba = [0.144, 0.144, 0.144, 0.144, 0.146, 0.16,  0.202, 0.24,  0.284, 0.313, 0.332, 0.337,
     0.34,  0.321, 0.276, 0.24,  0.214]
     
     
     f, ax = plt.subplots(2)
     ax[0].plot(M_eg, Ca_eg,'o-b', label='Ca Egip')
     ax[0].set_xlim([min(M_ba), max(M_ba)])
     ax[0].set_title('Ca vs Mach')
     ax[1].plot(M_ba, Ca_ba,'*-r', label='Cd Baran')
     ax[1].set_xlim([min(M_ba), max(M_ba)])
     ax[1].set_title('Ca vs Mach')
     
     plt.show()
**** cortito y al pie
     plt.subplot(121)
***** ej
     import numpy as np
     import matplotlib.pyplot as plt
     
     M_eg = [0.1,  0.6,  0.8,  0.9,  0.95, 1.,   1.05, 1.1,  1.2,  1.35, 1.5,  1.75, 2.  ]
     Ca_eg= [0.144, 0.144, 0.146, 0.167, 0.221, 0.327, 0.383, 0.381, 0.37,  0.353, 0.338, 0.314,
     0.294]
     M_ba = [0.01,  0.4,   0.6,   0.7,   0.8,   0.9,   0.95,  0.975, 1.,    1.025, 1.05,  1.1,
     1.2,   1.5,   2.,    2.5,   3.   ]
     Ca_ba = [0.144, 0.144, 0.144, 0.144, 0.146, 0.16,  0.202, 0.24,  0.284, 0.313, 0.332, 0.337,
     0.34,  0.321, 0.276, 0.24,  0.214]


     #--------------------------------------------
     # Plots
     plt.subplot(121)
     plt.plot(M_eg, Ca_eg,'o-b', label='Ca Egip')
     plt.grid()
     plt.legend()

     plt.subplot(122)
     plt.plot(M_ba, Ca_ba,'*-r', label='Cd Baran')
     plt.grid()
     plt.legend()

     plt.show()
*** plot con legends avanzado
    https://matplotlib.org/stable/gallery/text_labels_and_annotations/tex_demo.html#sphx-glr-gallery-text-labels-and-annotations-tex-demo-py
**** Ej, indentar a la hora de usar en .py
     # ploteo avanzado con latex, usar python3
     import numpy as np
     import matplotlib
     matplotlib.rcParams['text.usetex'] = True
     import matplotlib.pyplot as plt
     
     # interface tracking profiles
     N = 500
     delta = 0.6

     fig, ax = plt.subplots(figsize=(6, 4), tight_layout=True)
     
     X = np.linspace(-1, 1, N)
     ax.plot(X, (1 - np.tanh(4 * X / delta)) / 2,    # phase field tanh profiles
     X, (1.4 + np.tanh(4 * X / delta)) / 4, "C2",  # composition profile
     X, X < 0, "k--")                        # sharp interface

     # legend
     ax.legend(("phase field", "level set", "sharp interface"),
     shadow=True, loc=(0.01, 0.48), handlelength=1.5, fontsize=16)
     
     # the arrow
     ax.annotate("", xy=(-delta / 2., 0.1), xytext=(delta / 2., 0.1),
     arrowprops=dict(arrowstyle="<->", connectionstyle="arc3"))
     ax.text(0, 0.1, r"$\delta$",
     color="black", fontsize=24,
     horizontalalignment="center", verticalalignment="center",
     bbox=dict(boxstyle="round", fc="white", ec="black", pad=0.2))
     
     # Use tex in labels
     ax.set_xticks([-1, 0, 1])
     ax.set_xticklabels(["$-1$", r"$\pm 0$", "$+1$"], color="k", size=20)
     
     # Left Y-axis labels, combine math mode and text mode
     ax.set_ylabel(r"\bf{phase field} $\phi$", color="C0", fontsize=20)
     ax.set_yticks([0, 0.5, 1])
     ax.set_yticklabels([r"\bf{0}", r"\bf{.5}", r"\bf{1}"], color="k", size=20)
     
     # Right Y-axis labels
     ax.text(1.02, 0.5, r"\bf{level set} $\phi$",
     color="C2", fontsize=20, rotation=90,
     horizontalalignment="left", verticalalignment="center",
     clip_on=False, transform=ax.transAxes)

     # Use multiline environment inside a `text`.
     # level set equations
     eq1 = (r"\begin{eqnarray*}"
     r"|\nabla\phi| &=& 1,\\"
     r"\frac{\partial \phi}{\partial t} + U|\nabla \phi| &=& 0 "
     r"\end{eqnarray*}")
     ax.text(1, 0.9, eq1, color="C2", fontsize=18,
     horizontalalignment="right", verticalalignment="top")
     
     # phase field equations
     eq2 = (r"\begin{eqnarray*}"
     r"\mathcal{F} &=& \int f\left( \phi, c \right) dV, \\ "
     r"\frac{ \partial \phi } { \partial t } &=& -M_{ \phi } "
     r"\frac{ \delta \mathcal{F} } { \delta \phi }"
     r"\end{eqnarray*}")
     ax.text(0.18, 0.18, eq2, color="C0", fontsize=16)

     ax.text(-1, .30, r"gamma: $\gamma$", color="r", fontsize=20)
     ax.text(-1, .18, r"Omega: $\Omega$", color="b", fontsize=20)
     
     plt.show()

*** close/clear figures
**** plt.clf()
     clear figure: deletes all the figure but not close the windows. In subplots, just delete the indicated figure
**** plt.close()
     plt.close('all')
     close figure: close the current windows, if no specified otherwise.
**** plt.cla()
     clear axis
**** save figure
     dir = '~/Documents/CIMEC/popurri/'
     plt.savefig(dir+'plas.png',dpi=200)
** presione enter
   comando para que para continuar se debe presionar la tecla enter

   input("Presione enter") # esto es para que pause y cont con (enter)
** print
*** similar fprintf
    import numpy as np
    data = np.array([1, 2, 3, 4])
    coef_readed = False
    print('\nBefore calling bar: {} {}'.format(data,coef_readed))
    print("\nBefore calling bar: {} {}".format(data,coef_readed)) 
    # print("\nBefore calling bar: {data} {coef_readed}")
    print('\n*- - - - - - - - - - - - - - *')
    print('Fin! Prog OK\n')
*** avanzado
    #ver estimacion.py en ~/Documents/CIMEC/Tesis/estimacion/
    print(("%3f: %s" % (k, sol["status"]))) # float
    print(("%3d: %s" % (k, sol["status"]))) # entero
** underscore "_"
   https://dbader.org/blog/meaning-of-underscores-in-python#:~:text=The%20underscore%20prefix%20is%20meant,public%E2%80%9D%20variables%20like%20Java%20does.
*** Single Trailing Underscore: var_  -> evitar conflicto nombres
    Se usa para evitar el conflicto de nombres, generalmente como ciertos
    nombres ya est'an tomados, por clases, etc, se coloca el underscore
    atras
**** ej
     >>> def make_object(name, class):
     SyntaxError: "invalid syntax"
     
     >>> def make_object(name, class_):
     ...     pass
*** Single Leading Underscore: _var -> variable interna
    solo x convencción (en lo que respecta a variables y métodos).
    es una sugerencia de la comunidad programadora, 
    y solo significa que es una variable interna, nada más
    No hace diferencia entre clase publica y privada. En realidad se usa
    el "_" antes para decir: "hey, esto no realmente significa que es
    parte de la interfaz pública de la clase. Mejor dejemoslo solo"
**** ej:
     class Test:
     def __init__(self):
     self.foo = 11
     self._bar = 23
    # result python
     >>> t = Test()
     >>> t.foo
     11
     >>> t._bar
     23
*** Double Leading Underscore: __var -> manglear
    esto indica al interprete de python que re-escriba el nombre del 
    atributo para evitar conflictos de nombres en las subclases, cuando
    la clase se expanda.
    Esto se denomina name mangling (destrozar, pasar x exprimidor)
*** Double Leading and Trailing Underscore: __var__ -> cosas esp
    al tener leading and trailing dundle, no se los manglea sino que 
    se los deje para cosas especiales, por ejem:
    __init__ para constructores
    __call__ p hacer un objeto llamable
**** ej:
     class PrefixPostfixTest:
     def __init__(self):
     self.__bam__ = 42
     # en pantalla
     >>> PrefixPostfixTest().__bam__
     42
*** Sinegle Underscore: _
    se usa para decir que la variable es temporal o insignificante
**** ej
     cont en for temporal 
*** dunder
    dunder, es una expresion para abreviar "double underscore", ej:
    dunder bazz: __baz
    dunder baz dunder:  __baz__ (creo q el 'ultimo dunder se omite)
** random
   generate a vector with random numbers
*** ex
    import random
    import numpy as np
    import matplotlib.pyplot as plt

    long = 10
    vector = [random.randint(-3,4) for _ in range(long)]
    prom = [np.mean(vector) for _ in vector]
    print("Vector: ", vector)
    print("Prom: {}".format(np.mean(vector)))
    plt.plot(vector, '.');plt.plot(prom, label='prom');plt.title('vector={}'.format(vector));plt.legend();plt.show()

** size/shape 
   x = [1,2,3]
   print(np.shape(x))
** stadistics
   desviación standard, (sigma): indica dispersion de los resultados 
   respecto a la media (promedio)
   varianza, (sigma)^2: similar a la desviación standard (sigma) al 
   cuadrado
   primero se calcula la viarianza y luego el desvio es la raiz cuad
   de la varianza, por lo tanto, siempre dstd>0
   promedio: sería el valor medio, la suma de toda la muestra dividido 
   la cantidad total de muestras.
   mediana: es el valor medio después de haber ordenado de forma 
   ascendente todos los valores. Quiere decir el valor por el cual 
   existe 50% de la población debajo y por sobre este. Si la muestra es
   par, divide la suma de los dos números por dos.
   moda: es el valor que aparece más veces
*** ej
    import numpy as np

    #velocidad = [32, 111, 138, 28, 59, 77, 97]
    vel = [99, 86, 87, 88, 111, 86, 103, 87, 94, 78, 77, 85, 86]
    dstd = np.std(vel)
    var = np.var(vel)
    prom = np.mean(vel)
    mediana = np.median(vel)
    
    # for the mode, use the scipy "mode" method
    from scipy import stats
    moda = stats.mode(vel)
    
    print("La muestra de velocidad es:")
    print("{}\n".format(vel))
    print("La desviación standard ($\sigma$): {} ".format(dstd))
    print("La varianza ($\sigma^2$): {} ".format(var))
    print("El promedio: {} ".format(prom))
    print("La mediana: {} ".format(mediana))
    print("La moda: {} ".format(moda))
    
** strings
*** replace   
    reemplazar espacios/x por otro caracter
**** ej:
     # script for changing white spaces into underscore

     def reemplazar_espacios(cadena):
          nueva_cadena = cadena.replace(" ", "_")
	  return nueva_cadena

     # Ejemplo de uso
     texto = input("Ingrese una cadena de texto: ")
     resultado = reemplazar_espacios(texto)
     print("Resultado:\n{}".format(resultado))

     print('#--------------------------------------------')
     print('\n FIN, OK!')
*** split
    incorporar el siguiente metodo para leer las fuerzas aerodinamicas que se deben calcular en fuerzas totales. Incorporar estas sentencias 
    en la clase Aux.AerodynamicCoefEstimator. Also verified the type thta the input is a string
**** ej
# incorporar el siguiente metodo para leer las fuerzas aerodinamicas que se deben calcular en fuerzas totales. Incorporar estas sentencias en la clase Aux.AerodynamicCoefEstimator. Also verified the type thta the input is a string
#t = 'drag,drop,more'
t = ' magnus, drag'
#t = 'tito'
#t=[3]

#t = 3
if isinstance(t, str):  # Verificar si t es una cadena (str)
    # Dividir por comas y luego unir los resultados por espacios
    p = ' '.join(t.split(',')).split()

    wordFound = False  # Bandera para seguir si se encuentra alguna palabra clave

    for i in p:
        i = i.upper()  # Convertir la palabra a mayúsculas

        if i == 'DRAG':
            print('La fuerza Tot incluye DRAG')
            wordFound = True
        elif i == 'LIFT':
            print('La fuerza Tot incluye LIFT')
            wordFound = True
        elif i == 'MAGNUS':
            print('La fuerza Tot incluye MAGNUS')
            wordFound = True

    if not wordFound:
        print('¡Alerta! Ninguna de las palabras clave (DRAG, LIFT, MAGNUS) fue encontrada.')
else:
    print(f'¡Alerta! La variable no es una cadena (str).\nt: [{t}]')
    
** swapping values
   a = 23
   b = 45
   # en otros prog se usaba una variable aux
   aux = a
   a = b
   b = a
   # en python use this short-hand
   a,b = b,a
** tupla
   # tupla != lista
   # tupla, arreglos de datos no homogeneos
   a = (1,2,1+j,'5')
   
*** verificar si esta dentro
    1+j in a
   
** table - pandas - SQL
   pandas library se usa muchas veces para reemplazar a SQL
*** métodos populares de pandas
sea df el dataFrame:
df = pd.dataFrame(tabla,csv,etc)
**** head() y tail():
Descripción: Muestra las primeras o últimas filas del DataFrame.
***** ej
df.head()  # Muestra las primeras 5 filas por defecto
df.tail(10)  # Muestra las últimas 10 filas
**** info()
Proporciona información sobre el DataFrame, incluyendo tipos de datos y valores no nulos.
***** ej
df.info()
**** describe()
Proporciona estadísticas descriptivas para columnas numéricas.
***** ej
Proporciona estadísticas descriptivas para columnas numéricas.
**** shape
Retorna una tupla con la cantidad de filas y columnas del DataFrame.
***** ej
df.shape
**** columns
Retorna una lista con los nombres de las columnas del DataFrame.
***** ej
df.columns
**** index
Retorna el índice del DataFrame.
***** ej
df.index
**** loc[] y iloc[]
Permiten acceder a un grupo de filas y columnas por etiquetas o índices
***** ej
df.loc[1:3, ['Columna1', 'Columna2']]
df.iloc[1:3, [0, 1]]
**** isin()
Filtra filas basadas en si los valores están presentes en una lista.
***** ej
df[df['Columna'].isin(['valor1', 'valor2'])]
**** groupby()
Agrupa el DataFrame según una o varias columnas
***** ej
df.groupby('Columna').mean()
**** sort_values()
Ordena el DataFrame por valores específicos en una o varias columnas.
***** ej
df.sort_values(by='Columna', ascending=False)
**** drop()
Elimina filas o columnas del DataFrame
***** ej
df.drop(['Columna'], axis=1)
**** fillna()
Rellena los valores NaN con un valor específico o utilizando una estrategia de interpolación.
***** ej
df.fillna(valor)
**** isna() y notna()
Retorna un DataFrame de la misma forma que df, pero con True o False según si un elemento es 
NaN o no NaN, respectivamente.
***** ej
df.isna()
df.notna()
**** apply()
Aplica una función a lo largo de un eje del DataFrame.
***** ej
df['Columna'].apply(funcion)
**** pivot_table()
Crea una tabla dinámica a partir de un DataFrame.
***** ej
pd.pivot_table(df, values='Valor', index='Index', columns='Columna', aggfunc='mean')
*** arreglos - series - listas_en_pandas
    En pandas, una Serie es una estructura de datos unidimensional 
    similar a un arreglo o una lista en Python, pero con etiquetas
    en lugar de índices enteros. Cada elemento en una Serie está
    asociado a una etiqueta o un índice, lo que facilita el acceso
    y la manipulación de los datos.
**** ex1
     import pandas as pd

     # Crear una Serie a partir de una lista
     serie_ejemplo = pd.Series([10, 20, 30, 40], 
     index=['a', 'b', 'c', 'd'], name='lista random')

     # Acceder a elementos por etiqueta
     print(serie_ejemplo['b'])  # Imprimirá 20

*** incorporar un vector fila a un dataFrame
    ver tmb table/arreglos - series
**** ex1
     import pandas as pd
     import numpy as np

     # Supongamos que tienes un DataFrame llamado tabla_gral
     tabla = pd.DataFrame({'Columna_A': [1, 2, 3], 'Columna_B': [4, 5, 6]})

     # Arreglo ang
     ang = ['alpha', 'beta']

     # Crear una Serie a partir de ang
     ult_reng = pd.Series(ang, index=tabla.columns)

     # Agregar la fila a tabla_gral
     tabla = tabla.append(ult_reng, ignore_index=True)

     # Imprimir el DataFrame actualizado
     print(tabla)

*** built tabla
    data = {
    'Columna_A': [1, 2, 3],
    'Columna_B': [4, 5, 6],
    'Columna_C': [7, 8, 9]
     }

     df = pd.DataFrame(data)
*** intercambiar columnas
**** ex1
     # intercambia los valores de una con la otra, si se quieren intercambiar las 
     # columnas enteras
     import pandas as pd

     # Crear un DataFrame de ejemplo
     data = {
     'Columna_A': [1, 2, 3],
     'Columna_B': [4, 5, 6],
     'Columna_C': [7, 8, 9]
     }

     df = pd.DataFrame(data)

     # Intercambiar las columnas "Columna_A" y "Columna_B"
     df['Columna_A'], df['Columna_B'] = df['Columna_B'].copy(), df['Columna_A'].copy()

     # Mostrar el DataFrame resultante
     print(df)

*** incorporar columna
**** ex1 - met: corchetes    
    data = {
    'Col_A': [1, 2, 3],
    'Col_B': [4, 5, 6],
    'Col_C': [7, 8, 9]
     }

     df = pd.DataFrame(data)

     df['Cd0'] = np.zeros(len(data['Col_A']))
     # en caso de incorporar vectores de distinto tamaño, se debe usar pd.concat
*** concatener columnas
**** ex igual tamaño
     import pandas as pd

     # Crear dos DataFrames de ejemplo
     data1 = {'A': [1, 2, 3], 'B': [4, 5, 6]}
     data2 = {'X': [7, 8, 9], 'Y': [10, 11, 12]}
     
     df1 = pd.DataFrame(data1)
     df2 = pd.DataFrame(data2)
     
     # Omitir la primera columna de df2
     df2 = df2.iloc[:, 1:]  # Esto elimina la primera columna
     
     # Concatenar los DataFrames horizontalmente
     resultado = pd.concat([df1, df2], axis=1)
     
     # Mostrar el DataFrame resultante
     print(resultado)

**** ex !tamaño
     import pandas as pd

     # Se crea el diccionario con datos
     data1 = {'A': [1, 2, 3], 'B': [4, 5, 6]}

     # Crear dos DataFrames de ejemplo
     df = pd.DataFrame(data1)

     rows, cols = df.shape

     # Generar un vector Null del tamano del dataFrame
     tamano_deseado = 2

     # Crear una serie con NaN y el tamaño deseado
     newCol = pd.Series([None] * tamano_deseado, name='NewCol')
     
     df = pd.concat([df, newCol], axis=1)
     
*** eliminar columna
**** eliminar una columna específica
     # df.drop()
***** ex
     import pandas as pd

     # Crear dos DataFrames de ejemplo
     data1 = {'A': [1, 2, 3], 'B': [4, 5, 6]}
     data2 = {'X': [7, 8, 9], 'Y': [10, 11, 12], 'Z': [13, 14, 15]}  # Agregamos una columna Z en df2
     
     df1 = pd.DataFrame(data1)
     df2 = pd.DataFrame(data2)
     
     # Eliminar la columna del medio (Y) de df2
     df2 = df2.drop('Y', axis=1)
     
     # Concatenar los DataFrames horizontalmente
     resultado = pd.concat([df1, df2], axis=1)
     
     # Mostrar el DataFrame resultante
     print(resultado)

**** eliminar 1er columna
***** ex
      import pandas as pd

      # Crear dos DataFrames de ejemplo
      data1 = {'A': [1, 2, 3], 'B': [4, 5, 6]}
      data2 = {'X': [7, 8, 9], 'Y': [10, 11, 12]}
      
      df1 = pd.DataFrame(data1)
      df2 = pd.DataFrame(data2)
      
      # Omitir la primera columna de df2
      df2 = df2.iloc[:, 1:]  # Esto elimina la primera columna
      
      # Concatenar los DataFrames horizontalmente
      resultado = pd.concat([df1, df2], axis=1)
      
      # Mostrar el DataFrame resultante
      print(resultado)

*** filtrar columnas con designaciones especiales
    tengo un hear de la siguiente manera:
    Index(['Time', 'Cd', 'Cs', 'Cl', 'CmRoll', 'CmPitch', 'CmYaw', 'Cd(f)',
          'Cd(r)', 'Cs(f)', 'Cs(r)', 'Cl(f)', 'Cl(r)'],
	  dtype='object')
**** filtro las que tienen (f) o (r) y me quedo con esas variables
     # se usa el '\' para indicar el caracter especial del paréntesis y además
     # '|' indica OR en booleano
     col_filtradas = df.filter(regex='\(f\)|\(r\)', axis=1)
**** al revéz, filtro según un criterio y me quedo con lo otro
     # uso el signo de negación '~'
     col_filtradas2 = coef.loc[:, ~coef.columns.str.contains('\(f\)|\(r\)')]
*** guardar/escribir datos en archivo
**** ej
df.to_csv('nombre_del_archivo.csv', index=False)

#index=False no se guardan los índices de las columnas
*** exploring data - most frequency commands
**** ej
import pandas as pd
import seaborn as sns

fileName = 'pepe.txt'
# Read data
data = pd.readcsv(fileName)

# Displays first fewRows
print(data.head())

# Summery statics
print(data.describe())

# Check for missing values
# isnull method will give a boolean is is null or not
# data.isnull() gives the dataFrame boolean
print(data.isnull().sum())

# Drops rows with missing values
dataCleaned = data.dropna()

# Correlation Values
# corr() method

correlationMatrix = data_cleaned.corr()

plt.figure(figsize=(10,8))
sns.heatmap(correlationMatrix, annot = True, cmap = 'coolwarm')
plt.title('Correlation HeatMap')
plt.show()
*** crear archivo datos csv
    crear archivo csv with pandas
**** ej
     # script para generar ptos de blockMesh dynamesh
#tengo la sigueinte lsita de ptos, hacer dos archivos *.csv con los puntos ib y ob
import csv

vi = 0.7
vo = 1

#// Inner blocks
a0=(-vi, -vi, -vi)
b0=( vi, -vi, -vi)
c0=( vi,  vi, -vi)
d0=(-vi,  vi, -vi)
e0=(-vi, -vi,  vi)
f0=( vi, -vi,  vi)
g0=( vi,  vi,  vi)
h0=(-vi,  vi,  vi)

ib = [a0, b0, c0, d0, e0, f0, g0, h0]
     
#// Outer blocks
a1=(-vo, -vo, -vo)
b1=( vo, -vo, -vo)
c1=( vo,  vo, -vo)
d1=(-vo,  vo, -vo)
e1=(-vo, -vo,  vo)
f1=( vo, -vo,  vo)
g1=( vo,  vo,  vo)
h1=(-vo,  vo,  vo)

ob = [a1, b1, c1, d1, e1, f1, g1, h1]

# Guardar puntos internos en CSV
with open('puntos_ib.csv', 'w', newline='') as csvfile:
    csvwriter = csv.writer(csvfile)
    csvwriter.writerow(['X', 'Y', 'Z'])
    csvwriter.writerows(ib)

# Guardar puntos externos en CSV
with open('puntos_ob.csv', 'w', newline='') as csvfile:
    csvwriter = csv.writer(csvfile)
    csvwriter.writerow(['X', 'Y', 'Z'])
    csvwriter.writerows(ob)

*** leer datos de un csv con pandas
    cuando se tienen espacios en la cabecera del archivo, y se quieren omitir:
    usar el metodo: skipinitialspace
**** ej
     import pandas as pd
     data = pd.read_csv('./Forces_proc.txt', skiprows = 6, skipinitialspace=True)
     # columnas, guardamos en una lista
     cols = list(data.columns) 
*** orden columnas segun criterio
**** ex
     import pandas as pd
     
     # Crear un DataFrame de ejemplo
     data = {
     'Nombre': ['Alice', 'Bob', 'Charlie'],
     'Edad': [25, 30, 35],
     'Ciudad': ['Nueva York', 'Los Ángeles', 'Chicago']
     }
     
     df = pd.DataFrame(data)
     
     # Definir el orden deseado de las columnas
     orden_deseado = ['Ciudad', 'Edad', 'Nombre']
     
     # Crear un nuevo DataFrame con las columnas en el orden deseado
     df_ordenado = df[orden_deseado]
     
     # Mostrar el DataFrame resultante
     print(df_ordenado)

*** ex1 pandas
    # script that estimates the standard coef from a flight
    import pandas as pd
    import matplotlib.pyplot as plt

    def crear_tabla_coef(datos, rangos_mach):
        sumas = [0.0] * (len(rangos_mach) - 1)
        cantidades = [0] * (len(rangos_mach) - 1)
   
        for mach, coeficiente in datos:
            for i in range(len(rangos_mach) - 1):
                if rangos_mach[i] <= mach < rangos_mach[i + 1]:
                    sumas[i] += coeficiente
                    cantidades[i] += 1
   
        promedios = [suma / cantidad if cantidad > 0 else 0.0 for suma, cantidad in zip(sumas, cantidades)]
   
        resultados = pd.DataFrame({
            'Rango de Mach': [f'{rangos_mach[i]}-{rangos_mach[i + 1]}' for i in range(len(rangos_mach) - 1)],
            'Suma de Coeficientes': sumas,
            Cantidad de Valores': cantidades,
            'Promedio de Coeficientes': promedios
        })
      
        return resultados, promedios
   
    def crear_tabla_coef2(datos, rangos_mach):
        sumas = [0.0] * (len(rangos_mach) - 1)
        cantidades = [0] * (len(rangos_mach) - 1)
   
        for mach, coeficiente in datos:
            for i in range(len(rangos_mach) - 1):
                if rangos_mach[i] < mach <= rangos_mach[i + 1]:
                    sumas[i] += coeficiente
                    cantidades[i] += 1
   
        promedios = [suma / cantidad if cantidad > 0 else 0.0 for suma, cantidad in zip(sumas, cantidades)]
   
        resultados = pd.DataFrame({
            'Rango de Mach': [f'{rangos_mach[i]}-{rangos_mach[i + 1]}' for i in range(len(rangos_mach) - 1)],
            'Suma de Coeficientes': sumas,
            'Cantidad de Valores': cantidades,
            'Promedio de Coeficientes': promedios
        })
   
        return resultados, promedios
   
   
    # Ejemplo de uso:
    datos = [
        (0.5, 0.1),
        (0.8, 0.2),
        (1.2, 0.3),
        (1.5, 0.4),
        (2.0, 0.5),
        (2.5, 0.6),
    ]
   
    # Se debe agregar el valor 0.0, para generar un grupo, pero desp no se tiene en cuenta
    rangos_mach = [0.0, 0.01, 0.60, 0.80, 0.90, 0.95, 1.00, 1.05, 1.10, 1.20, 1.35, 1.50, 1.75, 2.00, 5.00]
    #coef = list(zip(mach, cmahat))

    tabla_resultados, prom = crear_tabla_coef(datos, rangos_mach)
    #tabla_resultados2, prom2 = crear_tabla_coef2(coef, rangos_mach)
    print(tabla_resultados)
   
    #prom = prom[1:]
   
    #plt.plot(rangos_mach[1:],cmarbd,'o-',label='cma rbd');plt.plot(rangos_mach[1:],prom,'o-',label='cma hat T1');plt.plot(rangos_mach[1:],prom2,'o-',label='cma hat T2');plt.legend();plt.grid()
    #dir = '/home/zeeburg/Downloads/delete/'
    #plt.savefig(dir+'tabla_mach.pdf');plt.show()
   
*** ex2 pandas
       # script que para un coef estimado a lo largo de todo un vuelo, 
       # se genera la tabla de coef según el #mach
   
       import pandas as pd
   
       # Ejemplo de vector de datos (puedes reemplazarlo con tus propios datos)
       # datos = [#mach, coef]
    datos = [
             (0.5, 0.1),
	     (0.8, 0.2),
	     (1.2, 0.3),
	     (1.5, 0.4),
	     (2.0, 0.5),
	     (2.5, 0.6),
	     ]

     # Definir los rangos de número de Mach
     rangos_mach = [0.0, 1.0, 2.0, 3.0]  # Puedes ajustar estos rangos según tus necesidades

     # Inicializar listas para las sumas y las cantidades en cada rango
     sumas = [0.0] * (len(rangos_mach) - 1)
     cantidades = [0] * (len(rangos_mach) - 1)

     # Recorrer el vector de datos y sumar los coeficientes en los rangos correspondientes
     for mach, coeficiente in datos:
        for i in range(len(rangos_mach) - 1):
            if rangos_mach[i] <= mach < rangos_mach[i + 1]:
                 sumas[i] += coeficiente
		 cantidades[i] += 1

      # Calcular el promedio en cada rango (dividir la suma por la cantidad)
      promedios = [suma / cantidad if cantidad > 0 else 0.0 for suma, cantidad in zip(sumas, cantidades)]

      # Crear una tabla (DataFrame) de pandas para mostrar los resultados
      resultados = pd.DataFrame({
      'Rango de Mach': [f'{rangos_mach[i]}-{rangos_mach[i + 1]}' for i in range(len(rangos_mach) - 1)],
      'Suma de Coeficientes': sumas,
      'Cantidad de Valores': cantidades,
      'Promedio de Coeficientes': promedios
      })

      # Imprimir la tabla de resultados
      print(resultados)

*** ex3 numeros not included in lista
    # script for testing pandas
    
    import pandas as pd
    
    a = pd.Series([1,2,3,4,5], name='Serie A')
    b = pd.Series([4,5,6,7,8], name='Serie B')
    
    df = pd.DataFrame({a.name: a, b.name: b})
    
    print('La tabla siguinte presenta los valores a,b')
    print(df)

    # para ver los elementos no incluidos usamos el método isin 
    ainb = a.isin(b)
    bina = b.isin(a)

    anotinb = pd.Series(a[~ainb], name='A not in B')
    print('Los valores de a no incluídos en b son:\n{}'.format(anotinb))
*** multicolumns
    para tener multicolumnas, usar el método pd.MultiIndex.from_tuples
**** ex1
     import pandas as pd
     
     # Crear un diccionario con datos de ejemplo
     data = {
     'A': [1, 2, 3],
     'B': [4, 5, 6],
     'C': [7, 8, 9]
     }
     
     # Crear una multicolumna con tres columnas
     multi_columns = pd.MultiIndex.from_tuples([('Grupo 1', 'Columna 1'),
     ('Grupo 1', 'Columna 2'),
     ('Grupo 2', 'Columna 3')])
     
     # Crear un DataFrame a partir del diccionario y la multicolumna
     df = pd.DataFrame(data, columns=multi_columns)
     
     # Mostrar el DataFrame
     print(df)

** varios
*** agregar
** warnings
*** error np.arrays length
    when facing with arrays with different length, there would be an error. To Face
    it you can avoid the warning and use list in stead of arrays, or handle the array
    as an object
**** avoid warning
     import warnings
     warnings.filterwarnings("ignore", category=np.VisibleDeprecationWarning) 
**** handle the array as object
     You can add dtype = object when you create your numpy array as:

     numpy.array([[1,2,3],[4,5,6]], dtype = object)
     or if you change a list or a tuple called 'a' to a numpy array code as:

     numpy.asarray(a, dtype = object)   
** zip
    la función zip, retorna un objeto zip, que es un iterador de tuplas
    donde los primeros valores de cada tupla se pasan juntos, y asi
    sucesivamente
*** zip, mershear dos tuplas
**** ej
     a1 = ("John", "Charles", "Mike", "Nico")
     a = ("John", "Charles", "Mike")
     b = ("1", "Christy", "Monica","pp")

     x = zip(a, b)
     x1 = zip(a1, b)
     #use the tuple() function to display a readable version of the result:

     print(tuple(x))
     print(tuple(x1))
*** desglosar una lista en valores, indices, etc**** ej
    zipped = [(1, 'a'), (2, 'b'), (3, 'c')]
    number, iter = zip(*zipped) 
   
    print(number={})
    iter(iter={})
*** merging two list with different sizes/lengths
**** ej
     # example of zip with different length iterables
     from itertools import zip_longest
     names = ['Alice', 'Bob']
     scores = [85, 92, 78]
     zipped = zip_longest(names, scores, fillvalue = 'N/A')
     
     value1, value2 = zip(*zipped) #el asterisco es el desconstructor del objeto
     print(f'values1:{value1}')
     print(f'values2:{value2}')
* OOP
  progrmacion orientada a objetos
** ver los metodos y atributos de una clase:
# Crear una instancia de la clase
objeto = MiClase()
   
# Obtener todos los nombres disponibles en la clase
nombres = dir(objeto)
   
# Filtrar para mostrar solo los métodos
metodos = [nombre for nombre in nombres if callable(getattr(objeto, nombre))]

# Filtrar para mostrar solo los atributos (variables)
atributos = [nombre for nombre in nombres if not callable(getattr(objeto, nombre))]

print("Métodos:", metodos)
print("Atributos:", atributos)
   
# Si se quieren filtrar los métodos y atributos mágicos/especiales
metodos_filtrados = [nombre for nombre in metodos if not nombre.startswith('__')]
atributos_filtrados = [nombre for nombre in atributos if not nombre.startswith('__')]

print("Métodos filtrados:", metodos_filtrados)
print("Atributos filtrados:", atributos_filtrados)

** indicar info, doc de una clase
   para documentar una clase y sus respectivos métodos, hay que colocar triple comillas a modo
   de comentario, y lluego se accede como un atributo denominado doc con dunder
*** ej:
class OpenFOAM:
    """
    Read results of OpenFOAM simulation and store it in the instance as a dictionary.
    Metohds: read_results, filter_results, plot_results.
    """

#$print(OpenFOAM.__doc__)
* otro
** matlab2python cheatsheet
   http://mathesaurus.sourceforge.net/matlab-numpy.html
<<<<<<< Updated upstream
   
=======
** teoría
*** instancias   
    una isntancia es un objeto específico creado a partir de una clase, la que tiene sus atributos (variables) y métodos (funciones).
**** ej
     # ejmplo de clase
     class Car:
          def __init__(self, brand, model):
          self.brand = brand
	  self.model = model

     # en cosola ejecutar
     myCar = Car('Peugeot', 308)
